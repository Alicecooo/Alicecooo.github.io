<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>有点意思，没点意思（一） | Thwords twbeats</title><meta name="keywords" content="CSAPP"><meta name="author" content="织"><meta name="copyright" content="织"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="有点意思，没点意思（一）"><meta name="application-name" content="有点意思，没点意思（一）"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="有点意思，没点意思（一）"><meta property="og:url" content="https://alicecooo.github.io/2025/08/10/%E6%9C%89%E7%82%B9%E6%84%8F%E6%80%9D%EF%BC%8C%E6%B2%A1%E7%82%B9%E6%84%8F%E6%80%9D%EF%BC%88%E4%B8%80%EF%BC%89/index.html"><meta property="og:site_name" content="Thwords twbeats"><meta property="og:description" content="第一章 数 程序员和编译器不能用表达式（x-y&amp;lt;0）代替（x&amp;lt;y），因为它可能会产生溢出，也不能用表达式（-x&amp;gt;-y）来替代，因为在补码表示中负数和正数的范围是不对称的。“ 没意思（一） 逻辑运算符与位运算符 区别一：运算对象与结果类型  逻辑运算符 &amp;amp;&amp;amp;amp"><meta property="og:locale" content="zh"><meta property="og:image" content="https://pic1.imgdb.cn/item/68987a3758cb8da5c816a63a.png?_r_=f5a4d755-028e-80e4-4bfb-947faaf7a14a"><meta property="article:author" content="织"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pic1.imgdb.cn/item/68987a3758cb8da5c816a63a.png?_r_=f5a4d755-028e-80e4-4bfb-947faaf7a14a"><meta name="description" content="第一章 数 程序员和编译器不能用表达式（x-y&amp;lt;0）代替（x&amp;lt;y），因为它可能会产生溢出，也不能用表达式（-x&amp;gt;-y）来替代，因为在补码表示中负数和正数的范围是不对称的。“ 没意思（一） 逻辑运算符与位运算符 区别一：运算对象与结果类型  逻辑运算符 &amp;amp;&amp;amp;amp"><link rel="shortcut icon" href="https://pic1.imgdb.cn/item/67d94fb988c538a9b5c03ffb.png"><link rel="canonical" href="https://alicecooo.github.io/2025/08/10/%E6%9C%89%E7%82%B9%E6%84%8F%E6%80%9D%EF%BC%8C%E6%B2%A1%E7%82%B9%E6%84%8F%E6%80%9D%EF%BC%88%E4%B8%80%EF%BC%89/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Thwords twbeats',
  title: '有点意思，没点意思（一）',
  postAI: '',
  pageFillDescription: '第一章 数, 区别一：运算对象与结果类型, 没意思（二）浮点数, 1. 规格化数（Normal Numbers, 2. 非规格化数（Denormal Numbers, 3. 无穷大（Infinity）, 4. NaN（非数Not a Number）, 第二章 汇编, 没意思（三）寻址, 没意思（四）栈帧, 压栈过程（函数调用时）, 出栈过程（函数返回时）, 第三章 处理器, 没意思（五） 流水线, 流程, 流水线冒险, 第四章 存储器处理结构, 没意思（六）Cache, 前置, Interesting Problem, Cache 读写, 没意思（七）虚拟内存, 前置, TLB, 由来, 过程处理, 缺失与缺页, 第五章 链接, 没意思（八）链接, 处理流程, 三种对象文件, 静态链接, 可重定位目标文件, 符号表与符号, 链接过程, 符号解析, 局部符号引用解析, 全局符号引用解析, 重定位, 静态库与共享库, 静态库, 共享库第一章数程序员和编译器不能用表达式代替因为它可能会产生溢出也不能用表达式来替代因为在补码表示中负数和正数的范围是不对称的没意思一逻辑运算符与位运算符区别一运算对象与结果类型逻辑运算符操作对象是布尔值真假对应代码里非等逻辑判定结果也只有布尔值真或假即代码里的非或比如先判定两边条件真假再做逻辑运算位级运算符操作对象是二进制位整数的二进制形式按位逐位运算结果是整数对应二进制位运算后的数值比如是是按位与结果是即十进制区别二短路求值你提供内容里的核心区别逻辑运算符存在短路特性若通过第一个操作数就能确定整个表达式结果就不会执行第二个操作数像若为逻辑假左边已确定结果为假直接跳过避免除零错误同理为空指针时左边为假不执行避免空指针解引用崩溃位级运算符不存在短路会严格计算两个操作数再逐位做位运算比如不管是什么都会计算再对二进制位逐位与运算没意思二浮点数规格化数由来计算机要表示很大或很小的数比如或直接存整数会浪费位数规格化数采用科学计数法的二进制版是尾数是指数隐藏最高位的因为二进制科学计数法的整数部分一定是如所以省略这个只存后面的小数部分节省位空间提高精度结构符号位位正负指数位实际指数指数值偏移量方便表示正负指数尾数位存储中的隐含前面的例子数二进制是指数指数值二进制尾数是因为省略了前面的只存小数部分符号位最终二进制即十六进制非规格化数由来当数太小规格化数的指数最小是指数值因为但实际最小是这里可能记错正确是指数值对应但比更小的数怎么办非规格化数允许指数全为此时不隐藏最高位的而是用表示尾数可以是到全填补规格化数和之间的空隙避免下溢时直接归零提高精度连续性结构符号位位正负指数位全指数值对应实际指数尾数位直接存不隐含可以是全此时就是例子最小的正非规格化数尾数最低位是其余即位实际值因为位尾数对应小数部分加上指数总偏移二进制即十六进制和尾数全指数全符号位不同二进制分别是和无穷大由来当计算结果太大如无法用规格化数表示就用无穷大分为正无穷和负无穷结构符号位位正负指数位全指数值尾数位全表示无穷大是一个确定的边界值例子正无穷的结果二进制即十六进制负无穷符号位其余同上十六进制非数由来当计算结果无效如无法用任何数表示就用不是一个数不是一个确定的值而是表示这是一个错误的结果结构符号位位通常忽略有些系统用有些用但无意义指数位全和无穷大一样尾数位非只要不全就是不同尾数表示不同类型的比如信号和静默例子最简单的尾数最高位是其余二进制即十六进制的结果通常是一个具体尾数由编译器决定但指数一定全尾数非总结规格化数用科学计数法高效表示大多数普通数节省位数提高精度非规格化数填补规格化数和之间的空隙避免极小的数直接归零提高数值连续性无穷大表示计算溢出如除以的合理结果避免程序崩溃表示无效的计算如让程序知道这是一个错误无法继续计算第二章汇编没意思三寻址类型格式操作数值名称立即数立即数寻址寄存器寄存器寻址存储器绝对寻址存储器间接寻址存储器基址偏移量寻址存储器变址寻址存储器变址寻址存储器比例变址寻址存储器比例变址寻址存储器比例变址寻址存储器比例变址寻址操作数可以表示立即数常数值寄存器值或是来自内存的值比例因子必须是或者示例地址值寄存器值写下表给出所示操作数的值操作数值没意思四栈帧始终指向栈顶用于栈操作用于访问栈帧内的局部变量或参数通过偏移量栈压栈过程函数调用时保存返回地址当一个函数被调用时程序首先会将当前指令的下一条指令的地址即函数调用结束后要返回继续执行的地址压入栈中这是为了确保函数执行完毕后程序能回到正确的位置继续执行传递参数按照调用约定如语言中的等将调用函数的参数从右向左以为例依次压入栈中这样被调用函数可以按照顺序正确获取参数保存寄存器值为了防止被调用函数修改调用函数中正在使用的寄存器值通常会将调用函数中需要保护的寄存器如通用寄存器等的值压入栈中在函数返回前再将这些值恢复保证调用函数的执行不受影响分配局部变量空间在栈上为被调用函数的局部变量分配内存空间比如函数中定义的普通变量数组等它们的内存都在栈帧中分配执行函数体完成上述操作后程序跳转到被调用函数的入口地址开始执行函数体中的代码出栈过程函数返回时清理局部变量函数执行完毕后首先释放为局部变量分配的栈空间局部变量的生命周期随着函数执行结束而结束它们所占用的栈内存会被释放恢复寄存器值将之前压入栈中的寄存器值按照压入的相反顺序弹出恢复到原来的寄存器中这样调用函数中的寄存器状态就恢复到了函数调用前的样子清理参数根据调用约定将栈上的函数参数弹出在某些调用约定如中由调用函数负责清理参数而在另一些约定如中由被调用函数清理参数获取返回地址将栈顶保存的返回地址弹出程序跳转到该地址继续执行调用函数中函数调用之后的代码第三章处理器没意思五流水线流程取指依程序计数器从内存读指令拆分出指令代码功能等信息还确定下条指令地址译码从寄存器文件读操作数为执行做准备执行算术逻辑单元按指令操作算地址改栈指针等还可能处理条件跳转判断访存数据写入内存或从内存读出数据写回把执行结果写回寄存器文件更新把下条指令地址设为让处理器继续执行流水线冒险流水线冒险是处理器执行指令流水线中下条指令无法按预期在时钟周期执行的情况结构冒险因缺乏硬件支持而导致指令不能在预定的时钟周期内执行的情况本质硬件资源不够用多条指令抢同一套硬件导致流水线卡壳举例比如处理器只有一个存储器既得给取指阶段供应指令从内存读指令又得给访存阶段读写数据比如指令访问内存要是取指的指令和访存的指令撞车同一时钟周期都要访问内存硬件没法同时满足后面指令就得等流水线就断流这就是结构冒险数据冒险因无法提供指令执行所需数据而导致指令不能在预定的时钟周期内执行的情况本质指令之间数据依赖没处理好后面指令要用的数据前面指令还没算完没写回举例指令把和相加结果存在指令用的值减存在流水线里指令可能在译码执行阶段就需要的值但指令还没到写回阶段没把结果真正存进这时候指令拿到的是旧数据结果就会错这就是数据冒险很容易想到的解决办法就是轮空但这样会浪费大量时钟周期前推旁路相关概念一种最基本的解决方法是基于以下实现在解决数据冒险问题之前不需要等待指令的执行结束对于上述的代码序列一旦生成了加法运算的结果就可以将它用作减法运算的一个输入项从内部资源中直接提前得到缺少的运算项的过程称为前推或者旁路前推也称为旁路一种解决数据冒险的方法具体做法是从内部寄存器而非程序员可见的寄存器或存储器中提前取出数据前推这个名称来源于将结果从前面的指令直接发送到后面的指令的思想旁路这个名称来源于把寄存器堆中的结果直接传递到需要的单元中控制冒险因为取到的指令并不是所需要的或者说指令地址的变化并不是流水线所预期的而导致指令不能在预定的时钟周期内执行本质指令执行顺序被跳转分支指令打乱流水线不知道该取哪条指令导致断流举例指令如果等于跳转到处执行否则继续执行下条指令流水线在执行阶段才知道要不要跳转但取指阶段已经把下条指令读进来了如果真的跳转已经读的指令就没用了得重新取处的指令这期间流水线就会空转这就是控制冒险阻塞和预测阻塞一种可能的解决方法是取分支指令后立即阻塞流水线直到流水线确定分支指令的结果并知道下一条真正要执行的指令在哪为止预测计算机的确是采用预测的方法来处理分支的一种简单的预测方法就是总预测分支未发生当预测正确分支未发生的时候流水线会全速地执行只有当分支发生时流水线才会阻塞分支预测一种解决分支冒险的方法它预测分支结果并立即沿预测方向执行而不是等真正的分支结果确定后才开始执行第四章存储器处理结构没意思六前置块或行可存在于或不存在于中的信息的最小单元命中率在高层存储器中找到目标数据的存储访问比例缺失率在高层存储器中没有找到目标数据的存储访问比例命中时间访问某存储器层次结构所需要的时间包括了判断当前访问是命中还是缺失所需的时间缺失代价将相应的块从低层存储器替换到高层存储器所需的时间包括访问块将数据逐层传输将数据插入发生缺失的层和将信息块传送给请求者的时间有效位表中的一个字段用来标识一个块是否含有一个有效数据标记表中的一个字段包含了地址信息这些地址信息可以用来判断中的字是否就是所请求的字高速缓存存储器补充块是数据搬运的最小套餐主存和不是单个字节来回传数据而是一次性传一个块比如块大小是字节字主存给传数据时不是只传个字节而是一次性传个字节的块这么做是为了利用程序的局部性原理程序访问内存时往往会连续访问相邻数据比如数组遍历指令顺序执行提前把一块数据搬进下次访问附近数据时直接从拿不用再跑主存效率更高块的大小决定偏移位数块越大包含的字节越多需要的偏移位数也越多因为要定位块内具体字节比如块大小字节偏移位只有个字节不用定位块大小字节偏移位对应块内个字节位置块大小字节偏移位对应个位置块在里的占位逻辑里的每个槽位可以理解为的一个存储位置刚好存一个块的数据再加上标记和有效位标记存主存地址的高位特征用来判断这个块是不是要访问的主存数据有效位标记这个块里的数据是否有效比如刚加载的新数据有效替换出去的旧数据可能无效块数据从主存搬过来的一块数据比如字节为什么用中间位映射直接组相联与全相联直接相联映射固定的映射关系全相联映射灵活的映射关系组相联映射前两种方案的折中方法直接相联映射直接相联映射的策略在内存块和缓存块之间建立起固定的映射关系一个内存块总是映射到同一个缓存块上如前置所展示的全相联映射对于直接映射存在个问题问题缓存利用不充分每个内存块只能映射到固定的位置上即使上有空闲位置也不会使用问题块冲突率高直接映射会频繁出现块冲突影响缓存命中率为了改进直接相联映射的缺点全相联映射的策略是允许内存块映射到任何一个块上组相联组相联高速缓存中的行匹配比直接映射高速缓存中的更复杂因为它必须检查多个行的标记位和有效位以确定所请求的字是否在集合中传统的内存是一个值的数组以地址作为输入并返回存储在那个地址的值另一方面相联存储器是一个对的数组以为输入返回与输入的相匹配的对中的值因此我们可以把组相联高速缓存中的每个组都看成一个小的相联存储器是标记和有效位而就是块的内容组相联映射组相联映射结合了直接相联映射和全相联映射的优点组相联映射的策略是将分为多组每个内存块固定映射到一个分组中又允许映射到组内的任意块显然组相联的分组为时就等于全相联映射而分组等于块个数时就等于直接映射兼顾速度与灵活性查找范围限于组内快于全相联组内多块可选冲突失效少于直接映射硬件成本适中缺点是仍可能发生组内冲突且组大小路数需权衡路数越多成本越高读写写直达也译为写通过或写穿写操作总是同时更新和下一存储器层次以保持二者一致性当执行写操作时同时更新缓存和主存确保缓存与主存中的数据始终保持一致优点数据一致性最强缓存和主存实时同步无需担心缓存块替换时的数据丢失实现简单无需标记缓存块是否被修改无需脏位问题写操作延迟高每次写操作都要等待主存更新完成而主存速度远慢于缓存会拖累效率写缓冲一个保存等待写入主存数据的缓冲队列作为写直达策略的优化手段在缓存与主存之间增加一个临时缓冲队列当执行写操作时先将数据写入缓存和写缓冲随后由硬件异步将缓冲中的数据批量写入主存无需等待主存完成写入即可继续执行优点减少等待时间通过缓冲掩盖主存写入的延迟提升写操作效率兼容写直达的一致性最终仍会将数据同步到主存保持一致性问题缓冲容量有限若连续写操作过快可能导致缓冲溢出仍需等待增加硬件复杂度需要管理缓冲队列的读写顺序和冲突如读操作需先检查缓冲写回当发生写操作时新值仅仅被写入块中只有当修改过的块被替换时才写到较低层存储结构中执行写操作时只更新缓存中的数据不立即写入主存仅当该缓存块被替换出缓存时才将修改过的数据写回主存通过脏位标记哪些块被修改过优点写操作性能极高避免频繁写入主存尤其适合对同一缓存块的多次连续写操作只需一次最终写回问题数据一致性较弱缓存与主存可能暂时不一致若发生断电或缓存故障可能丢失未写回的数据实现复杂需要维护脏位标记并在替换时判断是否需要写回主存写直达写直达是写操作同时更新主存的策略当发生写缺失要写的数据不在里时有两种处理方式写分配流程从主存取回对应数据块放入再在里改写数据相当于先读入再修改写不分配流程不把主存数据读入直接写主存仅修改主存跳过比如操作系统填零一页没有必要读入数据再修改写回写回是只改替换时再回写主存的策略实现比写直达复杂核心差异在缺失处理和执行周期缺失处理的风险写直达里数据和主存一致就算写缺失标记不匹配直接写主存即可无数据冲突写回里可能存改过但没回写主存的数据脏数据如果写操作触发缺失必须先把脏数据块回写主存否则会丢失修改执行周期的差异写直达写操作可一个周期完成读标记匹配则改主存不匹配则触发缺失直接写主存写回写操作需两个周期第一周期查是否命中命中则第二周期改或依赖写缓冲优化把数据先放缓冲流水线并行处理让写操作看似一个周期完成没意思七虚拟内存前置计算机系统的主存被组织成一个由个连续的字节大小的单元组成的数组每字节都有一个唯一的物理地址物理寻址虚拟存储器中块被称为页访问缺失则被称为缺页在虚拟存储器中处理器产生一个虚拟地址再结合软硬件转换成一个物理地址然后就可以被用来访问主存了如果还拿图书馆作类比我们可以认为一本书的书名就是虚拟地址物理地址则是这本书在图书馆中的位置它可能是图书馆的索书号虚拟内存与物理映射补充一页表程序计数器以及寄存器确定了一个虚拟机的状态如果我们想让另一个虚拟机使用处理器我们必须保存该状态随后在恢复了该状态之后虚拟机就可以继续执行我们通常称该状态为一个进程如果一个进程占据了处理器那么这个进程就是活跃的否则就认为它是非活跃的操作系统可以通过加载进程的状态令一个进程活跃起来同时激活程序计数器进程将会在程序计数器中保存的值处开始执行补充二为了追踪读入主存中的页是否被写过可以在页表中增加一个脏位当页中任何字被写时就将这一位置位如果操作系统选择替换某一页脏位指明了在把该页所占用的主存让给另一页之前是否需要将该页写回磁盘因此一个修改过的页也通常被称为脏页为了帮助操作系统估算最近最少使用的页一些计算机提供了一个引用位或者称为使用位当一页被访问时该位被置位操作系统定期将引用位清零然后再重新记录这样就可以判定在这段特定时间内哪些页被访问过有了这些使用信息操作系统就可以从那些最近最少访问的页中选择一页通过检查其引用位是否关闭由来由于页表存放在主存中因此程序每次访存至少需要两次第一次访存先获得物理地址第二次访存才获得数据提高访问性能的关键在于依靠页表的访问局部性当一个转换的虚页号被使用时它可能在不久的将来再次被用到因为对该页中字的引用同时具有时间局部性和空间局部性因此现代处理器都包含一个特殊的以跟踪最近使用过的地址变换这个特殊的地址转换通常称为快表将其称为地址变换高速缓存更精确就相当于记录目录中的一些书的位置的小纸片我们在纸片上记录一些书的位置并且将小纸片当成图书馆索书号的这样就不用一直在整个目录中搜索了快表用于记录最近使用地址的映射信息的高速缓存从而可以避免每次都要访问页表过程处理的每个标记项存放虚页号的一部分每个数据项中存放了物理页号由于我们每次访问的是而不是页表需要包括其他状态位如脏位和引用位每次访问我们都要在中查找虚页号如果命中物理页号就用来形成地址相应的引用位被置位如果处理器执行的是写操作脏位同样要被置位如果发生缺失我们必须判断是发生缺页还是仅仅是一次缺失如果该页在主存中那么缺失只是一次转换缺失在这种情况下处理器可以通过将页表中的变换装载到中并且重新访问来进行缺失处理如果该页不在主存中缺失就是一次真的缺页在这种情况下处理器调用操作系统的异常处理由于中的项比主存中的页数少得多发生缺失会比缺页频繁得多缺失既可以通过硬件处理也可以通过软件处理实际上两种方法的性能差别很小这是因为无论哪种方法需要执行的基本操作都是一样的在发生了缺失并且已经在页表中找到了缺失的变化时我们就需要从中选择一项进行替换由于表项中包含了引用位和脏位当替换某一项时需要把这些位复制回页表项中这些位是表项中唯一可以修改的部分利用写回策略只是在缺失的时候将这些表项写回而不是任何写操作都写回是非常有效的因为我们期望缺失率更低一些系统使用其他技术来近似引用位和脏位以消除除了缺失后装入新表项之外写的必要总流程缺失与缺页页在主存中只需要创建缺失的表项页不在主存中需要将控制权交给操作系统来解决缺页操作系统使用虚拟地址查找页表项并在磁盘上找到被访问的页的位置选择替换一个物理页如果被选中的页被修改过需要在把新的虚拟页装入之前将这个物理页写回到磁盘上启动读操作将被访问的页从磁盘上取回到所选择的物理页的位置上其他虚拟寻址一种使用虚拟地址而不是物理地址访问的别名使用两个地址访问同一个目标的情形一般发生在虚拟存储器中两个虚拟地址对应到同一个物理页时物理寻址使用物理地址寻址的第五章链接没意思八链接处理流程预处理器将语言代码转化成文件对应于预处理命令编译器语言代码经过编译器的处理成为汇编代码汇编器汇编代码经过汇编器的处理或成为对象程序链接器对象程序以及所需静态库经过链接器的处理或最终成为计算机可执行的程序加载器将可执行程序加载到内存并进行执行和三种对象文件所谓的对象文件实际上是一个统称具体来说有以下三种形式可重定位目标文件每个文件都是由对应的文件通过编译器和汇编器生成包含代码和数据可以与其他可重定位目标文件合并创建一个可执行或共享的目标文件可执行目标文件由链接器生成可以直接通过加载器加载到内存中充当进程执行的文件包含代码和数据共享目标文件在中被称为是类特殊的可重定位目标文件可以在链接静态共享库时加入目标文件或加载时或运行时动态共享库被动态的加载到内存并执行静态链接静态链接可重定位目标文件解析解析符号表与符号每个可重定位目标模块都有一个符号表它包含定义和引用的符号的信息全局符号由模块定义且能被其他模块引用对应非静态函数和全局变量外部符号由其他模块定义被模块引用对应其他模块中定义的非静态函数和全局变量局部符号仅在模块内定义和引用对应带属性的函数和全局变量只能在模块内可见不能被其他模块引用补充说明中的符号表不包含对应本地非静态程序变量的符号因其在运行时栈中管理链接器不关心带属性的本地过程变量不在栈中管理编译器会在或为其分配空间并在符号表创建本地链接器符号函数中的变量不在栈中链接过程链接器主要是将有关的目标文件彼此相连接生成可加载可执行的目标文件链接器的核心工作就是符号表解析和重定位符号解析局部符号引用解析对于在相同模块中定义和引用的局部符号符号解析很简单因为编译器规定每个模块中每个局部符号只能有一个定义静态局部变量也会有本地链接器符号且名字唯一补充一函数定义属于在当前模块中定义对函数的引用与定义在相同模块中这里的函数的定义和函数对它的引用都在这一模块内就属于在相同模块中定义这种情况下符号的作用域局限于该模块编译器处理其引用和解析时范围明确规则也相对简单如局部符号每个模块只允许一个定义补充二模块内函数静态局部变量编译器会为其创建唯一本地链接器符号在上述代码中函数里的是静态局部变量编译器在处理时会为它生成独有的本地链接器符号当在函数内对进行引用操作如时链接器能根据编译器设定的规则迅速将引用和该变量的定义关联起来完成符号解析全局符号引用解析当编译器遇到非当前模块定义的符号变量或函数名时会假定该符号在其他模块定义生成链接器符号表条目并交给链接器处理若链接器在输入模块中找不到被引用符号的定义就会输出错误信息并终止链接过程以在机器上编译包含未定义函数调用的文件为例编译器可正常运行但链接器因无法解析的引用而终止并给出错误提示链接器只知道非静态的全局变量函数而对于局部变量一无所知局部非静态变量和局部静态变量的区别局部非静态变量会保存在栈中局部静态变量会保存在或中如果两个函数中定义了同名的静态变量会怎么样呢那也就是重整规则重定位一旦链接器完成了符号解析这一步就把代码中的每个符号引用和正好一个符号定义即它的一个输入目标模块中的一个符号表条目关联起来此时链接器就知道它的输入目标模块中的代码节和数据节的确切大小现在就可以开始重定位步骤了在这个步骤中将合并输入模块并为每个符号分配运行时地址重定位由两步组成重定位节和符号定义在这一步中链接器将所有相同类型的节合并为同一类型的新的聚合节例如来自所有输入模块的节被全部合并成一个节这个节成为输出的可执行目标文件的节然后链接器将运行时内存地址赋给新的聚合节赋给输入模块定义的每个节以及赋给输入模块定义的每个符号当这一步完成时程序中的每条指令和全局变量都有唯一的运行时内存地址了重定位节中的符号引用在这一步中链接器修改代码节和数据节中对每个符号的引用使得它们指向正确的运行时地址要执行这一步链接器依赖于可重定位目标模块中称为重定位条目的数据结构静态库与共享库静态库静态库是一个外部函数与变量的集合体静态库的文件内容通常包含一堆程序员自定的变量与函数其内容不像动态链接库那么复杂在编译期间由编译器与连接器将它集成至应用程序内并制作成目标文件以及可以独立运作的可执行文件而这个可执行文件与编译可执行文件的程序都是一种程序的静态创建具体过程就是把不同文件的文件通过打包成为一个文件支持增量更新如果有函数变动只需要重新编译改动的部分静态库链接器是如何解析外部引用的呢详细的步骤为扫描当前命令中的和文件扫描过程中维护一个当前未解析引用的列表扫描到新的或文件时试图去寻找未解析引用如果扫描结束时仍旧有为解析的引用则报错因为是按顺序查找所以实际上是有引用依赖问题的也就是说写编译命令的时候顺序是很重要的共享库共享库重定位动态库将标准库动态链接库的文本代码和数据重定位到某个内存段将的文本和数据重定位到另一个内存段重定位符号引用对程序中所有由和定义的符号的引用进行重定位确保这些引用指向正确的运行时地址控制权转移与共享库位置固定动态链接器完成上述操作后将控制权传递给应用程序从此刻起共享库如在内存中的位置固定程序执行过程中不再改变这保证了程序运行时对共享库符号引用的稳定性和一致性',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-08-10 18:58:15',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/callout_blocks.css"><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://pic1.imgdb.cn/item/67d94ddb88c538a9b5c03fc3.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Thwords twbeats</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CS/" style="font-size: 1.05rem;">CS<sup>6</sup></a><a href="/tags/CSAPP/" style="font-size: 1.05rem;">CSAPP<sup>1</sup></a><a href="/tags/JAVA/" style="font-size: 1.05rem;">JAVA<sup>1</sup></a><a href="/tags/Summary/" style="font-size: 1.05rem;">Summary<sup>1</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 1.05rem;">后端<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">August 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">March 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">February 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/CSAPP/" itemprop="url">CSAPP</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/CSAPP/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>CSAPP</span></a></span></div></div><h1 class="post-title" itemprop="name headline">有点意思，没点意思（一）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-08-10T10:37:42.000Z" title="发表于 2025-08-10 18:37:42">2025-08-10</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-08-10T10:58:15.020Z" title="更新于 2025-08-10 18:58:15">2025-08-10</time></span></div><div class="meta-secondline"></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://pic1.imgdb.cn/item/68987a3758cb8da5c816a63a.png?_r_=f5a4d755-028e-80e4-4bfb-947faaf7a14a"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://alicecooo.github.io/2025/08/10/%E6%9C%89%E7%82%B9%E6%84%8F%E6%80%9D%EF%BC%8C%E6%B2%A1%E7%82%B9%E6%84%8F%E6%80%9D%EF%BC%88%E4%B8%80%EF%BC%89/"><header><a class="post-meta-categories" href="/categories/CSAPP/" itemprop="url">CSAPP</a><a href="/tags/CSAPP/" tabindex="-1" itemprop="url">CSAPP</a><h1 id="CrawlerTitle" itemprop="name headline">有点意思，没点意思（一）</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">织</span><time itemprop="dateCreated datePublished" datetime="2025-08-10T10:37:42.000Z" title="发表于 2025-08-10 18:37:42">2025-08-10</time><time itemprop="dateCreated datePublished" datetime="2025-08-10T10:58:15.020Z" title="更新于 2025-08-10 18:58:15">2025-08-10</time></header><h1 id="第一章-数">第一章 数</h1>
<p>程序员和编译器不能用表达式（x-y&lt;0）代替（x&lt;y），因为它可能会产生溢出，也不能用表达式（-x&gt;-y）来替代，因为在补码表示中负数和正数的范围是不对称的。“</p>
<h2 id="没意思一-逻辑运算符与位运算符">没意思（一）
逻辑运算符与位运算符</h2>
<h3 id="区别一运算对象与结果类型">区别一：运算对象与结果类型</h3>
<ul>
<li><strong>逻辑运算符 <code>&amp;&amp;</code>、<code>||</code></strong>：<br />
操作对象是<strong>布尔值（真 / 假，对应代码里非 0/0
等逻辑判定）</strong>，结果也只有布尔值（真或假，即代码里的非 0 或 0
）。比如 <code>(3 &gt; 2) &amp;&amp; (5 &lt; 6)</code> ，先判定两边条件真假，再做逻辑运算。</li>
<li><strong>位级运算符 <code>&amp;</code>、<code>|</code></strong>：<br />
操作对象是<strong>二进制位（整数的二进制形式）</strong>，按位逐位运算，结果是<strong>整数（对应二进制位运算后的数值）</strong> 。比如 <code>5 &amp; 3</code>（5
是 <code>101</code>，3
是 <code>011</code> ），按位与结果是 <code>001</code>（即十进制 1
）。</li>
</ul>
<h3
id="区别二短路求值你提供内容里的核心区别">区别二：短路求值（你提供内容里的核心区别
）</h3>
<ul>
<li><strong>逻辑运算符 <code>&amp;&amp;</code>、<code>||</code></strong>：<br />
存在 “短路” 特性 ——
若通过<strong>第一个操作数</strong>就能确定整个表达式结果，就<strong>不会执行第二个操作数</strong>。<br />
像 <code>a &amp;&amp; 5/a</code> ，若 <code>a</code> 为 0（逻辑假
），<code>&amp;&amp;</code> 左边已确定结果为假，直接跳过 <code>5/a</code> ，避免除零错误；<code>p &amp;&amp; *p++</code> 同理，<code>p</code> 为空指针时，左边为假，不执行 <code>*p++</code> ，避免空指针解引用崩溃。</li>
<li><strong>位级运算符 <code>&amp;</code>、<code>|</code></strong>：<br />
不存在短路，<strong>会严格计算两个操作数</strong>，再逐位做位运算。比如 <code>a &amp; b</code> ，不管 <code>a</code> 是什么，都会计算 <code>b</code> ，再对二进制位逐位与运算
。</li>
</ul>
<h2 id="没意思二浮点数">没意思（二）浮点数</h2>
<h3 id="规格化数normal-numbers">1. 规格化数（Normal Numbers</h3>
<p><strong>由来</strong>：<br />
计算机要表示“很大”或“很小”的数（比如 <code>1000000</code> 或
<code>0.000001</code>），直接存整数会浪费位数。<br />
<strong>规格化数</strong>采用科学计数法的二进制版：<code>±1.xxxx... × 2^E</code>（<code>1.xxx</code>
是尾数，<code>E</code> 是指数）。<br />
- <strong>隐藏最高位的
<code>1</code></strong>：因为二进制科学计数法的整数部分一定是
<code>1</code>（如
<code>10.0=1.0×2^1</code>，<code>0.1=1.0×2^-1</code>），所以省略这个
<code>1</code>，只存后面的小数部分，节省 1 位空间，提高精度。</p>
<p><strong>结构</strong>：<br />
- <strong>符号位（1 位）</strong>：0 正，1 负<br />
- <strong>指数（8 位）</strong>：实际指数
<code>E = 指数值 - 127</code>（偏移量 127，方便表示正负指数）<br />
- <strong>尾数（23 位）</strong>：存储 <code>1.xxxx...</code> 中的
<code>xxxx...</code>（隐含前面的 <code>1</code>）</p>
<p><strong>例子</strong>：<br />
- <strong>数 <code>2.0</code></strong>：<br />
二进制是 <code>10.0 = 1.0 × 2^1</code>，<br />
指数 <code>E=1</code>，指数值 <code>=1+127=128</code>（二进制
<code>10000000</code>），<br />
尾数是 <code>0</code>（因为 <code>1.0</code> 省略了前面的
<code>1</code>，只存小数部分 <code>0</code>），<br />
符号位 <code>0</code>，<br />
最终二进制：<code>0 10000000 00000000000000000000000</code>，即十六进制
<code>0x40000000</code>。</p>
<h3 id="非规格化数denormal-numbers">2. 非规格化数（Denormal Numbers</h3>
<p><strong>由来</strong>：<br />
当数“太小”，规格化数的指数 <code>E</code> 最小是
<code>-126</code>（指数值 0，因为 <code>0-127=-127</code> 但实际最小是
<code>-126</code>，这里可能记错，正确是指数值 0 对应
<code>E=-126</code>），但比 <code>-126</code> 更小的数怎么办？<br />
<strong>非规格化数</strong>允许指数全为 <code>0</code>，此时
<strong>不隐藏最高位的 <code>1</code></strong>，而是用
<code>0.xxxx... × 2^-126</code> 表示，尾数可以是 <code>0</code> 到全
1，填补规格化数和 <code>0</code>
之间的“空隙”，避免“下溢”时直接归零，提高精度连续性。</p>
<p><strong>结构</strong>：<br />
- <strong>符号位（1 位）</strong>：0 正，1 负<br />
- <strong>指数（8 位）</strong>：全 0（指数值 0，对应实际指数
<code>E = -126</code>）<br />
- <strong>尾数（23 位）</strong>：直接存 <code>0.xxxx...</code>（不隐含
<code>1</code>，可以是全 0，此时就是 <code>0</code>）</p>
<p><strong>例子</strong>：<br />
- <strong>最小的正非规格化数</strong>：<br />
尾数最低位是 <code>1</code>，其余 0，即 <code>0.000...0001</code>（23
位），<br />
实际值 <code>= 0.000...0001 × 2^-126 = 2^-149</code>（因为
<code>23位尾数对应小数部分，加上指数</code> -126 <code>，总偏移</code>
-126-23=-149 <code>），     二进制：</code>0 00000000
00000000000000000000001<code>，即十六进制</code>0x00000001<code>。   - **+0 和 -0**：尾数全 0，指数全 0，符号位不同，二进制分别是</code>0x00000000<code>和</code>0x80000000`。</p>
<h3 id="无穷大infinity">3. 无穷大（Infinity）</h3>
<p><strong>由来</strong>：<br />
当计算结果“太大”（如 <code>1.0/0.0</code>），无法用规格化数表示，就用
<strong>无穷大</strong>。分为正无穷和负无穷。</p>
<p><strong>结构</strong>：<br />
- <strong>符号位（1 位）</strong>：0 正，1 负<br />
- <strong>指数（8 位）</strong>：全 1（指数值 255）<br />
- <strong>尾数（23 位）</strong>：全
0（表示无穷大是一个确定的“边界值”）</p>
<p><strong>例子</strong>：<br />
- <strong>正无穷</strong>：<code>1.0/0.0</code> 的结果，<br />
二进制：<code>0 11111111 00000000000000000000000</code>，即十六进制
<code>0x7F800000</code>。<br />
- <strong>负无穷</strong>：<code>-1.0/0.0</code>，符号位
1，其余同上，十六进制 <code>0xFF800000</code>。</p>
<h3 id="nan非数not-a-number">4. NaN（非数，Not a Number）</h3>
<p><strong>由来</strong>：<br />
当计算结果“无效”（如
<code>0.0/0.0</code>、<code>√-1</code>），无法用任何数表示，就用
<strong>NaN</strong>（“不是一个数”）。<br />
<strong>NaN
不是一个确定的值</strong>，而是表示“这是一个错误的结果”。</p>
<p><strong>结构</strong>：<br />
- <strong>符号位（1 位）</strong>：通常忽略（有些系统用 0，有些用
1，但无意义）<br />
- <strong>指数（8 位）</strong>：全 1（和无穷大一样）<br />
- <strong>尾数（23 位）</strong>：<strong>非 0</strong>（只要不全
0，就是 NaN，不同尾数表示不同类型的 NaN，比如“信号 NaN”和“静默
NaN”）</p>
<p><strong>例子</strong>：<br />
- <strong>最简单的 NaN</strong>：尾数最高位是 1，其余 0，<br />
二进制：<code>0 11111111 10000000000000000000000</code>，即十六进制
<code>0x7FC00000</code>。<br />
- <strong>0/0 的结果</strong>：通常是一个
NaN，具体尾数由编译器决定，但指数一定全 1，尾数非 0。</p>
<p>总结： 1.
<strong>规格化数</strong>：用科学计数法高效表示大多数普通数，节省位数，提高精度。<br />
2. <strong>非规格化数</strong>：填补规格化数和 0
之间的“空隙”，避免极小的数直接归零，提高数值连续性。<br />
3. <strong>无穷大</strong>：表示计算溢出（如除以
0）的合理结果，避免程序崩溃。<br />
4. <strong>NaN</strong>：表示无效的计算（如
0/0），让程序知道“这是一个错误，无法继续计算”。</p>
<h1 id="第二章-汇编">第二章 汇编</h1>
<h2 id="没意思三寻址">没意思（三）寻址</h2>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 22%" />
<col style="width: 44%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr>
<th>类型</th>
<th>格式</th>
<th>操作数值</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>立即数</td>
<td><code>$Imm</code></td>
<td><code>Imm</code></td>
<td>立即数寻址</td>
</tr>
<tr>
<td>寄存器</td>
<td><code>rₐ</code></td>
<td><code>R[rₐ]</code></td>
<td>寄存器寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><code>Imm</code></td>
<td><code>M[Imm]</code></td>
<td>绝对寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><code>(rₐ)</code></td>
<td><code>M[R[rₐ]]</code></td>
<td>间接寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><code>Imm(r_b)</code></td>
<td><code>M[Imm + R[r_b]]</code></td>
<td>（基址 + 偏移量）寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><code>(r_b, r_i)</code></td>
<td><code>M[R[r_b] + R[r_i]]</code></td>
<td>变址寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><code>Imm(r_b, r_i)</code></td>
<td><code>M[Imm + R[r_b] + R[r_i]]</code></td>
<td>变址寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><code>(r_i, s)</code></td>
<td><code>M[R[r_i]·s]</code></td>
<td>比例变址寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><code>Imm(r_i,s)</code></td>
<td><code>M[Imm + R[r_i]·s]</code></td>
<td>比例变址寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><code>(r_b, r_i, s)</code></td>
<td><code>M[R[r_b] + R[r_i]·s]</code></td>
<td>比例变址寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><code>Imm(r_b, r_i, s)</code></td>
<td><code>M[Imm + R[r_b] + R[r_i]·s]</code></td>
<td>比例变址寻址</td>
</tr>
</tbody>
</table>
<p>操作数可以表示立即数（常数）值、寄存器值或是来自内存的值。比例因子
<code>s</code> 必须是 1、2、4 或者 8</p>
<p><strong>示例</strong>：</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x100</td>
<td>0xFF</td>
</tr>
<tr>
<td>0x104</td>
<td>0xAB</td>
</tr>
<tr>
<td>0x108</td>
<td>0x13</td>
</tr>
<tr>
<td>0x10C</td>
<td>0x11</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>%rax</td>
<td>0x100</td>
</tr>
<tr>
<td>%rcx</td>
<td>0x1</td>
</tr>
<tr>
<td>%rdx</td>
<td>0x3</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><em>写下表，给出所示操作数的值</em>：</p>
<table>
<thead>
<tr>
<th>操作数</th>
<th>值</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>%rax</td>
<td>0 x 100</td>
<td></td>
</tr>
<tr>
<td>0 x 104</td>
<td>0 xAB</td>
<td></td>
</tr>
<tr>
<td>$0 x 108</td>
<td>0 x 108</td>
<td></td>
</tr>
<tr>
<td>(%rax)</td>
<td>0 xFF</td>
<td></td>
</tr>
<tr>
<td>4 (%rax)</td>
<td>0 xAB</td>
<td></td>
</tr>
<tr>
<td>9 (%rax,%rdx)</td>
<td>0 x 11</td>
<td></td>
</tr>
<tr>
<td>260 (%rcx,%rdx)</td>
<td>0 x 13</td>
<td></td>
</tr>
<tr>
<td>0 xFC (,%rcx, 4)</td>
<td>0 xFF</td>
<td></td>
</tr>
<tr>
<td>(%rax,%rdx, 4)</td>
<td>0 x 11</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="没意思四栈帧">没意思（四）栈帧</h2>
<ul>
<li><code>SP</code> 始终指向栈顶，用于栈操作（push/pop）。</li>
<li><code>BP</code> 用于访问栈帧内的局部变量或参数（通过偏移量）</li>
</ul>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/6898769e58cb8da5c816a5c0.png"
alt="栈.png" />
<figcaption aria-hidden="true">栈.png</figcaption>
</figure>
<h3 id="压栈过程函数调用时">压栈过程（函数调用时）</h3>
<ol type="1">
<li><strong>保存返回地址</strong>：当一个函数被调用时，程序首先会将当前指令的下一条指令的地址（即函数调用结束后要返回继续执行的地址）压入栈中
。这是为了确保函数执行完毕后，程序能回到正确的位置继续执行。</li>
<li><strong>传递参数</strong>：按照调用约定（如 C
语言中的 <code>cdecl</code> 、<code>stdcall</code> 等），将调用函数的参数从右向左（以<code>cdecl</code>为例）依次压入栈中。这样被调用函数可以按照顺序正确获取参数。</li>
<li><strong>保存寄存器值</strong>：为了防止被调用函数修改调用函数中正在使用的寄存器值，通常会将调用函数中需要保护的寄存器（如通用寄存器 <code>eax</code>、<code>ebx</code> 等）的值压入栈中
。在函数返回前，再将这些值恢复，保证调用函数的执行不受影响。</li>
<li><strong>分配局部变量空间</strong>：在栈上为被调用函数的局部变量分配内存空间。比如函数中定义的普通变量、数组等，它们的内存都在栈帧中分配。</li>
<li><strong>执行函数体</strong>：完成上述操作后，程序跳转到被调用函数的入口地址，开始执行函数体中的代码。</li>
</ol>
<h3 id="出栈过程函数返回时">出栈过程（函数返回时）</h3>
<ol type="1">
<li><strong>清理局部变量</strong>：函数执行完毕后，首先释放为局部变量分配的栈空间。局部变量的生命周期随着函数执行结束而结束，它们所占用的栈内存会被释放。</li>
<li><strong>恢复寄存器值</strong>：将之前压入栈中的寄存器值按照压入的相反顺序弹出，恢复到原来的寄存器中。这样，调用函数中的寄存器状态就恢复到了函数调用前的样子。</li>
<li><strong>清理参数</strong>：根据调用约定，将栈上的函数参数弹出。在某些调用约定（如 <code>cdecl</code>）中，由调用函数负责清理参数；而在另一些约定（如 <code>stdcall</code>）中，由被调用函数清理参数。</li>
<li><strong>获取返回地址</strong>：将栈顶保存的返回地址弹出，程序跳转到该地址，继续执行调用函数中函数调用之后的代码。</li>
</ol>
<h1 id="第三章-处理器">第三章 处理器</h1>
<h2 id="没意思五-流水线">没意思（五） 流水线</h2>
<h3 id="流程">流程</h3>
<ol type="1">
<li><strong>取指</strong>：依程序计数器（PC）从内存读指令，拆分出指令代码、功能等信息，还确定下条指令地址。</li>
<li><strong>译码</strong>：从寄存器文件读操作数，为执行做准备。</li>
<li><strong>执行</strong>：算术/逻辑单元（ALU）按指令操作，算地址、改栈指针等，还可能处理条件、跳转判断。</li>
<li><strong>访存</strong>：数据写入内存，或从内存读出数据。</li>
<li><strong>写回</strong>：把执行结果写回寄存器文件。</li>
<li><strong>更新 PC</strong>：把下条指令地址设为
PC，让处理器继续执行。</li>
</ol>
<h3 id="流水线冒险">流水线冒险</h3>
<p>流水线冒险是处理器执行指令流水线中，下条指令无法按预期在时钟周期执行的情况。</p>
<ul>
<li><strong>结构冒险（Structural Hazard）</strong></li>
<li>因缺乏硬件支持而导致指令不能在预定的时钟周期内执行的情况。
<ul>
<li><strong>本质</strong>：硬件资源不够用，多条指令“抢同一套硬件”，导致流水线卡壳。<br />
</li>
<li><strong>举例</strong>：<br />
比如处理器只有<strong>一个存储器</strong>，既得给取指阶段“供应指令”（从内存读指令），又得给访存阶段“读写数据”（比如
<code>lw</code> / <code>sw</code>
指令访问内存）。要是取指的指令和访存的指令“撞车”（同一时钟周期都要访问内存），硬件没法同时满足，后面指令就得等，流水线就“断流”——这就是结构冒险。</li>
</ul></li>
<li><strong>数据冒险（Data Hazard）</strong></li>
<li>因无法提供指令执行所需数据而导致指令不能在预定的时钟周期内执行的情况。
<ul>
<li><strong>本质</strong>：指令之间“数据依赖”没处理好，后面指令要用的数据，前面指令还没算完/没写回。<br />
</li>
<li><strong>举例</strong>：<br />
指令 1：<code>add $t0, $t1, $t2</code>（把 <code>$t1</code> 和
<code>$t2</code> 相加，结果存在 <code>$t0</code> ）<br />
指令 2：<code>sub $t3, $t0, $t4</code>（用 <code>$t0</code> 的值减
<code>$t4</code>，存在 <code>$t3</code> ）<br />
</li>
<li>流水线里，指令 2 可能在“译码/执行阶段”就需要 <code>$t0</code>
的值，但指令 1 还没到“写回阶段”（没把结果真正存进 <code>$t0</code>
）。这时候指令 2 拿到的 <code>$t0</code>
是旧数据，结果就会错——这就是数据冒险。</li>
</ul></li>
</ul>
<p>很容易想到的解决办法就是"轮空", 但这样会浪费大量时钟周期。</p>
<blockquote>
<p>[!note] 前推（旁路）相关概念
一种最基本的解决方法是基于以下实现：在解决数据冒险问题之前不需要等待指令的执行结束。对于上述的代码序列，一旦
ALU
生成了加法运算的结果，就可以将它用作减法运算的一个输入项。从内部资源中直接提前得到缺少的运算项的过程称为<strong>前推（forwarding）</strong>
或者<strong>旁路（bypassing）</strong> 。</p>
<ul>
<li>前推：也称为旁路。一种解决数据冒险的方法，具体做法是从内部寄存器而非程序员可见的寄存器或存储器中提前取出数据。</li>
<li>“前推”
这个名称来源于将结果从前面的指令直接发送到后面的指令的思想。“旁路”
这个名称来源于把寄存器堆中的结果直接传递到需要的单元中。</li>
</ul>
</blockquote>
<ul>
<li><strong>控制冒险（Control Hazard）</strong></li>
<li>因为取到的指令并不是所需要的（或者说指令地址的变化并不是流水线所预期的）而导致指令不能在预定的时钟周期内执行。
<ul>
<li><strong>本质</strong>：指令执行顺序“被跳转/分支指令打乱”，流水线不知道该“取哪条指令”，导致断流。<br />
</li>
<li><strong>举例</strong>：<br />
指令：<code>beq $t0, $t1, LABEL</code>（如果 <code>$t0</code> 等于
<code>$t1</code>，跳转到 <code>LABEL</code>
处执行；否则继续执行下条指令）<br />
</li>
<li>流水线在“执行阶段”才知道要不要跳转，但“取指阶段”已经把下条指令读进来了。如果真的跳转，已经读的指令就没用了，得重新取
<code>LABEL</code>
处的指令，这期间流水线就会“空转”——这就是控制冒险。</li>
</ul></li>
</ul>
<blockquote>
<p>[!note] 阻塞和预测 -
阻塞（stall）：一种可能的解决方法是取分支指令后立即阻塞流水线，直到流水线确定分支指令的结果并知道下一条真正要执行的指令在哪为止。
- 预测（predict）:
计算机的确是采用预测的方法来处理分支的。一种简单的预测方法就是总预测分支未发生。当预测正确（分支未发生）的时候，流水线会全速地执行。只有当分支发生时流水线才会阻塞。
-
分支预测：一种解决分支冒险的方法。它预测分支结果并立即沿预测方向执行，而不是等真正的分支结果确定后才开始执行。</p>
</blockquote>
<h1 id="第四章-存储器处理结构">第四章 存储器处理结构</h1>
<h2 id="没意思六cache">没意思（六）Cache</h2>
<h3 id="前置">前置</h3>
<ul>
<li>块或行：可存在于或不存在于 cache 中的信息的最小单元。</li>
<li>命中率：在高层存储器中找到目标数据的存储访问比例。</li>
<li>缺失率：在高层存储器中没有找到目标数据的存储访问比例。</li>
<li>命中时间：访问某存储器层次结构所需要的时间，包括了判断当前访问是命中还是缺失所需的时间。</li>
<li>缺失代价：将相应的块从低层存储器替换到高层存储器所需的时间，包括访问块、将数据逐层传输、将数据插入发生缺失的层和将信息块传送给请求者的时间。</li>
<li>有效位：表中的一个字段，用来标识一个块是否含有一个有效数据。</li>
<li>标记：表中的一个字段，包含了地址信息，这些地址信息可以用来判断 cache
中的字是否就是所请求的字。</li>
</ul>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/689871df58cb8da5c816a4b4.png"
alt="高速缓存存储器.png" />
<figcaption aria-hidden="true">高速缓存存储器.png</figcaption>
</figure>
<blockquote>
<p>[!note] 补充 - 块是 “数据搬运的最小套餐” 。 - 主存和 Cache 不是
“单个字节” 来回传数据，而是一次性传一个 “块”。 - 比如块大小是 4 字节（1
字），主存给 Cache 传数据时，不是只传 1 个字节，而是一次性传 4 个字节的
“块”。 - 这么做是为了利用程序的 “局部性原理”：程序访问内存时，往往会
“连续访问相邻数据”（比如数组遍历、指令顺序执行）。提前把 “一块数据” 搬进
Cache，下次访问附近数据时，直接从 Cache 拿，不用再跑主存，效率更高。 -
块的大小决定 “偏移位数” 。 - 块越大，包含的字节越多，需要的
“偏移（Offset）” 位数也越多（因为要定位块内具体字节）。 - 比如： -
块大小 = 1 字节 → 偏移 0 位（只有 1 个字节，不用定位）。 - 块大小 = 4
字节 → 偏移 2 位（2²=4，对应块内 4 个字节位置：00、01、10、11 ）。 -
块大小 = 8 字节 → 偏移 3 位（2³=8，对应 8 个位置）。 - 块在 Cache 里的
“占位” 逻辑 - Cache 里的每个 “槽位”（可以理解为 Cache
的一个存储位置），刚好存一个块的数据，再加上 “标记（Tag）” 和
“有效位（Valid Bit）”： - 标记（Tag）：存主存地址的
“高位特征”，用来判断这个块是不是 CPU 要访问的主存数据。 -
有效位：标记这个块里的数据是否
“有效”（比如刚加载的新数据有效，替换出去的旧数据可能无效）。 -
块数据：从主存搬过来的 “一块数据”（比如 4 字节）。</p>
</blockquote>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/689871df58cb8da5c816a4b1.png"
alt="Cache.png" />
<figcaption aria-hidden="true">Cache.png</figcaption>
</figure>
<h4 id="interesting-problem">Interesting Problem</h4>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/6898769e58cb8da5c816a5c2.png"
alt="为什么用中间位.png" />
<figcaption aria-hidden="true">为什么用中间位.png</figcaption>
</figure>
<h3 id="cache映射-直接组相联与全相联">Cache映射
直接、组相联与全相联</h3>
<ul>
<li>直接相联映射（Direct Mapped Cache）： 固定的映射关系；</li>
<li>全相联映射（Fully Associative Cache）： 灵活的映射关系；</li>
<li>组相联映射（N-way Set Associative Cache）：
前两种方案的折中方法。、</li>
</ul>
<p>（1） 直接相联映射 -
直接相联映射的策略：在内存块和缓存块之间建立起固定的映射关系，一个内存块总是映射到同一个缓存块上。如前置所展示的。</p>
<p>（2） 全相联映射 - 对于直接映射存在2个问题： -
问题1，缓存利用不充分：每个内存块只能映射到固定的位置上，即使Cache上有空闲位置也不会使用。
- 问题2，块冲突率高：直接映射会频繁出现块冲突，影响缓存命中率。</p>
<ul>
<li>为了改进直接相联映射的缺点，全相联映射的策略是：允许内存块映射到任何一个Cache块上。</li>
</ul>
<blockquote>
<p>[!note] 组相联
组相联高速缓存中的行匹配比直接映射高速缓存中的更复杂，因为它必须检查多个行的标记位和有效位，以确定所请求的字是否在集合中。传统的内存是一个值的数组，以地址作为输入，并返回存储在那个地址的值。另一方面，相联存储器是一个(key，value)对的数组，以key为输入，返回与输入的key相匹配的(key，value)对中的value值。因此，我们可以把组相联高速缓存中的每个组都看成一个小的相联存储器，key是标记和有效位，而value就是块的内容。</p>
</blockquote>
<p>（3） 组相联映射 -
组相联映射结合了直接相联映射和全相联映射的优点，组相联映射的策略是：将Cache分为多组，每个内存块固定映射到一个分组中，又允许映射到组内的任意Cache块。显然，组相联的分组为1时，就等于全相联映射，而分组等于Cache块个数时，就等于直接映射。
-
兼顾速度与灵活性：查找范围限于组内（快于全相联），组内多块可选（冲突失效少于直接映射），硬件成本适中；
缺点是仍可能发生组内冲突，且组大小（路数）需权衡（路数越多成本越高）。</p>
<h3 id="cache-读写">Cache 读写</h3>
<ul>
<li>写直达：也译为写通过或写穿。写操作总是同时更新cache和下一存储器层次，以保持二者一致性。</li>
<li>当 CPU
执行写操作时，<strong>同时更新缓存和主存</strong>，确保缓存与主存中的数据始终保持一致。
<ul>
<li>优点：
<ul>
<li>数据·一致性最强：缓存和主存实时同步，无需担心缓存块替换时的数据丢失。</li>
<li>实现简单：无需标记缓存块是否被修改（无需“脏位”）。</li>
</ul></li>
<li>问题：
<ul>
<li>写操作延迟高：每次写操作都要等待主存更新完成，而主存速度远慢于缓存，会拖累
CPU 效率。</li>
</ul></li>
</ul></li>
<li>写缓冲：一个保存等待写入主存数据的缓冲队列。</li>
<li>作为写直达策略的优化手段，在缓存与主存之间增加一个<strong>临时缓冲队列</strong>。当
CPU
执行写操作时，先将数据写入缓存和写缓冲，随后由硬件异步将缓冲中的数据批量写入主存，CPU
无需等待主存完成写入即可继续执行。
<ul>
<li>优点：
<ul>
<li>减少 CPU 等待时间：通过缓冲掩盖主存写入的延迟，提升写操作效率。</li>
<li>兼容写直达的一致性：最终仍会将数据同步到主存，保持一致性。</li>
</ul></li>
<li>问题：
<ul>
<li>缓冲容量有限：若连续写操作过快，可能导致缓冲溢出，仍需 CPU
等待。</li>
<li>增加硬件复杂度：需要管理缓冲队列的读写顺序和冲突（如读操作需先检查缓冲）。</li>
</ul></li>
</ul></li>
<li>写回：当发生写操作时，新值仅仅被写入cache块中，只有当修改过的块被替换时才写到较低层存储结构中。</li>
<li>CPU
执行写操作时，<strong>只更新缓存中的数据</strong>，不立即写入主存。仅当该缓存块被替换出缓存时，才将修改过的数据写回主存（通过“脏位”标记哪些块被修改过）
<ul>
<li>优点
<ul>
<li>写操作性能极高：避免频繁写入主存，尤其适合对同一缓存块的多次连续写操作（只需一次最终写回）。</li>
</ul></li>
<li>问题：
<ul>
<li>数据一致性较弱：缓存与主存可能暂时不一致，若发生断电或缓存故障，可能丢失未写回的数据。</li>
<li>实现复杂：需要维护“脏位”标记，并在替换时判断是否需要写回主存。</li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p>[!note] 写直达 写直达（Write - Through）是 “写操作同时更新 Cache +
主存” 的策略，当发生<strong>写缺失</strong>（要写的数据不在 Cache
里）时，有两种处理方式： 1. <strong>写分配（Write Allocate）</strong>：
- 流程：从主存取回对应数据块，放入 Cache，再在 Cache 里改写数据（相当于
“先读入，再修改” ）。</p>
<ol start="2" type="1">
<li><strong>写不分配（No Write Allocate）</strong>：
<ul>
<li>流程：不把主存数据读入 Cache，直接写主存（仅修改主存，跳过 Cache
）。</li>
<li>比如：操作系统填零一页，没有必要读入数据再修改</li>
</ul></li>
</ol>
</blockquote>
<blockquote>
<p>[!note] 写回 写回（Write - Back）是 “只改 Cache，替换时再回写主存”
的策略，实现比写直达复杂，核心差异在 缺失处理” 和 执行周期： 1.
<strong>缺失处理的风险</strong>： - 写直达：Cache
里数据和主存一致，就算写缺失、标记不匹配，直接写主存即可，无数据冲突。 -
写回：Cache 里可能存 “改过但没回写主存”
的数据（脏数据）。如果写操作触发缺失，<strong>必须先把脏数据块回写主存</strong>，否则会丢失修改。
2. <strong>执行周期的差异</strong>： - 写直达：写操作可 “一个周期”
完成（读标记→匹配则改 Cache + 主存；不匹配则触发缺失、直接写主存 ）。 -
写回：写操作需 “两个周期”（第一周期查是否命中；命中则第二周期改 Cache
），或依赖 <strong>写缓冲</strong> 优化（把数据先放缓冲，流水线并行处理，让写操作看似
“一个周期” 完成 ）。</p>
</blockquote>
<h2 id="没意思七虚拟内存">没意思（七）虚拟内存</h2>
<h3 id="前置-1">前置</h3>
<ul>
<li>计算机系统的主存被组织成一个由 M
个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址（Physical
Address，PA）。</li>
</ul>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/689871df58cb8da5c816a4af.png"
alt="物理寻址.png" />
<figcaption aria-hidden="true">物理寻址.png</figcaption>
</figure>
<ul>
<li>虚拟存储器中，块被称为页（page），访问缺失则被称为缺页（page
fault）。</li>
<li>在虚拟存储器中，处理器产生一个虚拟地址（virtual
address），再结合软硬件转换成一个物理地址（physical
address），然后就可以被用来访问主存了。</li>
<li>如果还拿图书馆作类比，我们可以认为一本书的书名就是虚拟地址，物理地址则是这本书在图书馆中的位置，它可能是图书馆的索书号。</li>
</ul>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/689871df58cb8da5c816a4b0.png"
alt="虚拟内存与物理映射.png" />
<figcaption aria-hidden="true">虚拟内存与物理映射.png</figcaption>
</figure>
<blockquote>
<p>[!note] 补充一
页表、程序计数器以及寄存器，确定了一个虚拟机的状态（state）。如果我们想让另一个虚拟机使用处理器，我们必须保存该状态。随后，在恢复了该状态之后，虚拟机就可以继续执行。我们通常称该状态为一个进程（process）。如果一个进程占据了处理器，那么这个进程就是活跃的（active），否则就认为它是非活跃的（in
-
active）。操作系统可以通过加载进程的状态令一个进程活跃起来，同时激活程序计数器，进程将会在程序计数器中保存的值处开始执行。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/6898769e58cb8da5c816a5bf.png"
alt="页表.png" /> &gt; [!note] 补充二 &gt; - Dirty bit &gt; -
为了追踪读入主存中的页是否被写过，可以在页表中增加一个脏位（dirty
bit）。当页中任何字被写时就将这一位置位。如果操作系统选择替换某一页，脏位指明了在把该页所占用的主存让给另一页之前，是否需要将该页写回磁盘。因此，一个修改过的页也通常被称为脏页（dirty
page）。 &gt; - Use bit &gt; -
为了帮助操作系统估算最近最少使用的页，一些计算机提供了一个引用位（reference
bit）或者称为使用位（use
bit），当一页被访问时该位被置位。操作系统定期将引用位清零，然后再重新记录，这样就可以判定在这段特定时间内哪些页被访问过。有了这些使用信息，操作系统就可以从那些最近最少访问的页中选择一页（通过检查其引用位是否关闭）。</p>
<h3 id="tlb">TLB</h3>
<h4 id="由来">由来</h4>
<ul>
<li>由于页表存放在主存中，因此程序每次访存至少需要两次：第一次访存先获得物理地址，第二次访存才获得数据。提高访问性能的关键在于依靠页表的访问局部性。</li>
<li>当一个转换的虚页号被使用时，它可能在不久的将来再次被用到，因为对该页中字的引用同时具有时间局部性和空间局部性。</li>
<li>因此，现代处理器都包含一个特殊的 cache
以跟踪最近使用过的地址变换。这个特殊的地址转换 cache
通常称为快表（Translation-Lookaside
Buffer，TLB）（将其称为地址变换高速缓存更精确）。</li>
<li>TLB
就相当于记录目录中的一些书的位置的小纸片；我们在纸片上记录一些书的位置，并且将小纸片当成图书馆索书号的
cache，这样就不用一直在整个目录中搜索了。</li>
<li>快表：用于记录最近使用地址的映射信息的高速缓存，从而可以避免每次都要访问页表。</li>
</ul>
<h4 id="过程处理">过程处理</h4>
<ul>
<li>TLB的每个标记项存放虚页号的一部分，每个数据项中存放了物理页号。由于我们每次访问的是TLB而不是页表，TLB需要包括其他状态位，如脏位和引用位。每次访问，我们都要在TLB中查找虚页号。</li>
<li>如果命中，物理页号就用来形成地址，相应的引用位被置位。</li>
<li>如果处理器执行的是写操作，脏位同样要被置位。</li>
<li>如果TLB发生缺失，我们必须判断是发生缺页还是仅仅是一次TLB缺失。</li>
<li>如果该页在主存中，那么TLB缺失只是一次转换缺失。在这种情况下，处理器可以通过将页表中的变换装载到TLB中并且重新访问来进行缺失处理。</li>
<li>如果该页不在主存中，TLB缺失就是一次真的缺页。在这种情况下，处理器调用操作系统的异常处理。由于TLB中的项比主存中的页数少得多，发生TLB缺失会比缺页频繁得多。
TLB缺失既可以通过硬件处理，也可以通过软件处理。</li>
<li>实际上，两种方法的性能差别很小，这是因为无论哪种方法，需要执行的基本操作都是一样的。在发生了TLB缺失，并且已经在页表中找到了缺失的变化时，我们就需要从TLB中选择一项进行替换。由于TLB表项中包含了引用位和脏位，当替换某一项时，需要把这些位复制回页表项中。这些位是TLB表项中唯一可以修改的部分。利用写回策略——只是在缺失的时候将这些表项写回而不是任何写操作都写回——是非常有效的，因为我们期望TLB
缺失率更低。一些系统使用其他技术来近似引用位和脏位，以消除除了缺失后装入新表项之外写TLB的必要。
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/689871df58cb8da5c816a4b3.png"
alt="TLB.png" /></li>
</ul>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/689871df58cb8da5c816a4b2.png"
alt="Cache总流程.png" />
<figcaption aria-hidden="true">Cache总流程.png</figcaption>
</figure>
<h4 id="缺失与缺页">缺失与缺页</h4>
<ul>
<li>页在主存中，只需要创建缺失的 TLB 表项。</li>
<li>页不在主存中，需要将控制权交给操作系统来解决缺页。
<ul>
<li>操作系统使用虚拟地址查找页表项，并在磁盘上找到被访问的页的位置。</li>
<li>选择替换一个物理页；如果被选中的页被修改过，需要在把新的虚拟页装入之前将这个物理页写回到磁盘上。</li>
<li>启动读操作，将被访问的页从磁盘上取回到所选择的物理页的位置上。 ###
其他</li>
</ul></li>
<li>虚拟寻址 cache：一种使用虚拟地址而不是物理地址访问的 cache。</li>
<li>别名：使用两个地址访问同一个目标的情形，一般发生在虚拟存储器中两个虚拟地址对应到同一个物理页时。</li>
<li>物理寻址 cache：使用物理地址寻址的 cache。</li>
</ul>
<h1 id="第五章-链接">第五章 链接</h1>
<h2 id="没意思八链接">没意思（八）链接</h2>
<h3 id="处理流程">处理流程</h3>
<ul>
<li><strong>预处理器</strong>：将 C 语言代码 (da. C)
转化成 <code>da.i</code> 文件
(<code>gcc –E</code>)，对应于预处理命令 <code>cpp</code></li>
<li><strong>编译器</strong>：C 语言代码 (da. C, wang. C)
经过编译器的处理 (<code>gcc -0g -S</code>) 成为汇编代码 (da. S, wang.
S)</li>
<li><strong>汇编器</strong>：汇编代码 (da. S, wang. S) 经过汇编器的处理
(<code>gcc</code> 或 <code>as</code>) 成为对象程序 (da. O, wang. O)</li>
<li><strong>链接器</strong>：对象程序 (da. O, wang. O) 以及所需静态库
(lib. A) 经过链接器的处理 (<code>gcc</code> 或 <code>ld</code>)
最终成为计算机可执行的程序</li>
<li><strong>加载器</strong>：将可执行程序加载到内存并进行执行，<code>loader</code> 和 <code>ld-linux.so</code></li>
</ul>
<h3 id="三种对象文件">三种对象文件</h3>
<p>所谓的对象文件 (Object File)
实际上是一个统称，具体来说有以下三种形式： - 可重定位目标文件
Relocatable object file (<code>.o</code> file) -
每个 <code>.o</code> 文件都是由对应的 <code>.c</code> 文件通过编译器和汇编器生成，包含代码和数据，可以与其他可重定位目标文件合并创建一个可执行或共享的目标文件
- 可执行目标文件 Executable object file (<code>a.out</code> file) -
由链接器生成，可以直接通过加载器加载到内存中充当进程执行的文件，包含代码和数据
- 共享目标文件 Shared object file (<code>.so</code> file) - 在 windows
中被称为 Dynamic Link Libraries
(DLLs)，是类特殊的可重定位目标文件，可以在链接 (静态共享库)
时加入目标文件或加载时或运行时 (动态共享库) 被动态的加载到内存并执行</p>
<h3 id="静态链接">静态链接</h3>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/689876e658cb8da5c816a5d4.png"
alt="静态链接.png" />
<figcaption aria-hidden="true">静态链接.png</figcaption>
</figure>
<h3 id="可重定位目标文件">可重定位目标文件</h3>
<ul>
<li><p> Executable and Linkable Format (ELF)   <img
src="https://pic1.imgdb.cn/item/6898769e58cb8da5c816a5c1.png"
alt="可重定位目标文件.png" /></p>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/6898761c58cb8da5c816a5b7.png"
alt="ELF解析1.png" />
<figcaption aria-hidden="true">ELF解析1.png</figcaption>
</figure>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/6898761c58cb8da5c816a5b5.png"
alt="ELF解析2.png" />
<figcaption aria-hidden="true">ELF解析2.png</figcaption>
</figure></li>
</ul>
<h3 id="符号表与符号">符号表与符号</h3>
<p>每个可重定位目标模块 m 都有一个符号表，它包含 m
定义和引用的符号的信息。</p>
<ul>
<li><p><strong>全局符号</strong>：由模块 m
定义且能被其他模块引用，对应非静态 C 函数和全局变量。</p></li>
<li><p><strong>外部符号</strong>：由其他模块定义，被模块 m
引用，对应其他模块中定义的非静态 C 函数和全局变量。</p></li>
<li><p><strong>局部符号</strong>：仅在模块 m 内定义和引用，对应带 static
属性的 C 函数和全局变量，只能在模块 m
内可见，不能被其他模块引用。</p></li>
<li><p><strong>补充说明</strong>：. Symtab
中的符号表不包含对应本地非静态程序变量的符号，因其在运行时栈中管理，链接器不关心。带
C static 属性的本地过程变量不在栈中管理，编译器会在. Data 或. Bss
为其分配空间，并在符号表创建本地链接器符号。==函数中的 static
变量不在栈中==。</p></li>
</ul>
<h3 id="链接过程">链接过程</h3>
<p>链接器主要是将有关的目标文件彼此相连接生成可加载、可执行的目标文件。链接器的核心工作就是符号表解析和重定位。</p>
<h4 id="符号解析">符号解析</h4>
<h5 id="局部符号引用解析">局部符号引用解析</h5>
<ul>
<li>对于在相同模块中定义和引用的局部符号，符号解析很简单。因为编译器规定每个模块中每个局部符号只能有一个定义，静态局部变量也会有本地链接器符号且名字唯一。</li>
</ul>
<p>补充一： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义，属于在当前模块（example.c）中定义  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printMessage</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    printMessage(); <span class="comment">// 对 printMessage 函数的引用，与定义在相同模块（example.c）中  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p>
<p>这里的 <code>printMessage</code> 函数的定义和 <code>main</code> 函数对它的引用，都在 <code>example.c</code> 这一模块内，就属于
“在相同模块中定义”。这种情况下，符号的作用域局限于该模块，编译器处理其引用和解析时，范围明确，规则也相对简单（如局部符号每个模块只允许一个定义）。</p>
<p>补充二： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块内函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 静态局部变量，编译器会为其创建唯一本地链接器符号</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> localVar = <span class="number">0</span>; </span><br><span class="line">    localVar++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Local static variable: %d\n&quot;</span>, localVar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    func();</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在上述代码中，<code>func</code> 函数里的
<code>localVar</code>
是静态局部变量。编译器在处理时，会为它生成独有的本地链接器符号。当在
<code>func</code> 函数内对 <code>localVar</code> 进行引用操作（如
<code>localVar++</code> ）时，链接器能根据编译器设定的规则，迅速将引用和该变量的定义关联起来，完成符号解析。</p>
<h5 id="全局符号引用解析">全局符号引用解析</h5>
<ul>
<li>当编译器遇到非当前模块定义的符号（变量或函数名
）时，会假定该符号在其他模块定义，生成链接器符号表条目并交给链接器处理。</li>
<li>若链接器在输入模块中找不到被引用符号的定义，就会输出错误信息并终止链接过程。以在
Linux 机器上编译包含未定义函数 <code>foo</code> 调用的
<code>linkerror.c</code> 文件为例，编译器可正常运行，但链接器因无法解析
<code>foo</code> 的引用而终止，并给出错误提示。</li>
</ul>
<p>链接器只知道非静态的全局变量/函数，而对于局部变量一无所知。局部非静态变量和局部静态变量的区别：
- 局部非静态变量会保存在栈中 -
局部静态变量会保存在 <code>.bss</code> 或 <code>.data</code> 中</p>
<p>如果两个函数中定义了同名的静态变量会怎么样呢？ 那也就是重整 <img
src="https://pic1.imgdb.cn/item/6898761c58cb8da5c816a5b6.png"
alt="符号重整.png" /></p>
<p>规则： <img
src="https://pic1.imgdb.cn/item/6898761c58cb8da5c816a5b4.png"
alt="符号解析规则.png" /></p>
<h5 id="重定位">重定位</h5>
<p>一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义（即它的一个输入目标模块中的一个符号表条目）关联起来。此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。重定位由两步组成：</p>
<ul>
<li>重定位节和符号定义。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输入模块的.
Data 节被全部合并成一个节，这个节成为输出的可执行目标文件的. Data
节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。<br />
</li>
<li>重定位节中的符号引用。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目（relocation
entry）的数据结构。</li>
</ul>
<h3 id="静态库与共享库">静态库与共享库</h3>
<h4 id="静态库">静态库</h4>
<ul>
<li>静态库是一个外部函数与变量的集合体。静态库的文件内容，通常包含一堆程序员自定的变量与函数，其内容不像动态链接库那么复杂，在编译期间由编译器与连接器将它集成至应用程序内，并制作成目标文件以及可以独立运作的可执行文件。而这个可执行文件与编译可执行文件的程序，都是一种程序的静态创建（static
build）</li>
<li>具体过程就是把不同文件的 .o 文件通过 Archiver 打包成为一个 .a
文件。Archiver
支持增量更新，如果有函数变动，只需要重新编译改动的部分。</li>
</ul>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/6898761c58cb8da5c816a5b2.png"
alt="静态库.png" />
<figcaption aria-hidden="true">静态库.png</figcaption>
</figure>
<p>链接器是如何解析外部引用的呢？详细的步骤为：</p>
<ul>
<li>扫描当前命令中的 <code>.o</code> 和 <code>.a</code> 文件</li>
<li>扫描过程中，维护一个当前未解析引用的列表</li>
<li>扫描到新的 <code>.o</code> 或 <code>.a</code> 文件时，试图去寻找未解析引用</li>
<li>如果扫描结束时仍旧有为解析的引用，则报错
因为是按顺序查找，所以实际上是有引用依赖问题的，也就是说写编译命令的时候，顺序是很重要的。</li>
</ul>
<h4 id="共享库">共享库</h4>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/6898761c58cb8da5c816a5b3.png"
alt="共享库.png" />
<figcaption aria-hidden="true">共享库.png</figcaption>
</figure>
<ul>
<li><strong>重定位动态库</strong>：
<ul>
<li>将 <code>libc.so</code>（标准 C
库动态链接库）的文本（代码）和数据重定位到某个内存段。</li>
<li>将 <code>libvector.so</code> 的文本和数据重定位到另一个内存段。</li>
</ul></li>
<li><strong>重定位符号引用</strong>：对 <code>prog21</code> 程序中所有由 <code>libc.so</code> 和 <code>libvector.so</code> 定义的符号的引用进行重定位，确保这些引用指向正确的运行时地址。</li>
<li><strong>控制权转移与共享库位置固定</strong>：动态链接器完成上述操作后，将控制权传递给应用程序。从此刻起，共享库（如 <code>libc.so</code>、<code>libvector.so</code>）在内存中的位置固定，程序执行过程中不再改变。这保证了程序运行时对共享库符号引用的稳定性和一致性。</li>
</ul>
</article><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2025/03/17/Spring/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/68987a3758cb8da5c816a63b.png?_r_=cc9361bd-ad4f-30c6-7832-c810d5621a4d" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/67d94ddb88c538a9b5c03fc3.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">世事悠悠混未了,年光冉冉今如许</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">织</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/Alicecooo" target="_blank" title="Github"></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">第一章 数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%A1%E6%84%8F%E6%80%9D%E4%B8%80-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.</span> <span class="toc-text">没意思（一）
逻辑运算符与位运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E4%B8%80%E8%BF%90%E7%AE%97%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%BB%93%E6%9E%9C%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">区别一：运算对象与结果类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E4%BA%8C%E7%9F%AD%E8%B7%AF%E6%B1%82%E5%80%BC%E4%BD%A0%E6%8F%90%E4%BE%9B%E5%86%85%E5%AE%B9%E9%87%8C%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.2.</span> <span class="toc-text">区别二：短路求值（你提供内容里的核心区别
）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%A1%E6%84%8F%E6%80%9D%E4%BA%8C%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">没意思（二）浮点数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E6%A0%BC%E5%8C%96%E6%95%B0normal-numbers"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 规格化数（Normal Numbers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E8%A7%84%E6%A0%BC%E5%8C%96%E6%95%B0denormal-numbers"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 非规格化数（Denormal Numbers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%A9%B7%E5%A4%A7infinity"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. 无穷大（Infinity）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nan%E9%9D%9E%E6%95%B0not-a-number"><span class="toc-number">1.2.4.</span> <span class="toc-text">4. NaN（非数，Not a Number）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B1%87%E7%BC%96"><span class="toc-number">2.</span> <span class="toc-text">第二章 汇编</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%A1%E6%84%8F%E6%80%9D%E4%B8%89%E5%AF%BB%E5%9D%80"><span class="toc-number">2.1.</span> <span class="toc-text">没意思（三）寻址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%A1%E6%84%8F%E6%80%9D%E5%9B%9B%E6%A0%88%E5%B8%A7"><span class="toc-number">2.2.</span> <span class="toc-text">没意思（四）栈帧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E6%A0%88%E8%BF%87%E7%A8%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6"><span class="toc-number">2.2.1.</span> <span class="toc-text">压栈过程（函数调用时）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BA%E6%A0%88%E8%BF%87%E7%A8%8B%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E6%97%B6"><span class="toc-number">2.2.2.</span> <span class="toc-text">出栈过程（函数返回时）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">第三章 处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%A1%E6%84%8F%E6%80%9D%E4%BA%94-%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">3.1.</span> <span class="toc-text">没意思（五） 流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%86%92%E9%99%A9"><span class="toc-number">3.1.2.</span> <span class="toc-text">流水线冒险</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">第四章 存储器处理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%A1%E6%84%8F%E6%80%9D%E5%85%ADcache"><span class="toc-number">4.1.</span> <span class="toc-text">没意思（六）Cache</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE"><span class="toc-number">4.1.1.</span> <span class="toc-text">前置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#interesting-problem"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">Interesting Problem</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cache%E6%98%A0%E5%B0%84-%E7%9B%B4%E6%8E%A5%E7%BB%84%E7%9B%B8%E8%81%94%E4%B8%8E%E5%85%A8%E7%9B%B8%E8%81%94"><span class="toc-number">4.1.2.</span> <span class="toc-text">Cache映射
直接、组相联与全相联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cache-%E8%AF%BB%E5%86%99"><span class="toc-number">4.1.3.</span> <span class="toc-text">Cache 读写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%A1%E6%84%8F%E6%80%9D%E4%B8%83%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">4.2.</span> <span class="toc-text">没意思（七）虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">前置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tlb"><span class="toc-number">4.2.2.</span> <span class="toc-text">TLB</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B1%E6%9D%A5"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">由来</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E5%A4%84%E7%90%86"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">过程处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E5%A4%B1%E4%B8%8E%E7%BC%BA%E9%A1%B5"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">缺失与缺页</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E9%93%BE%E6%8E%A5"><span class="toc-number">5.</span> <span class="toc-text">第五章 链接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%A1%E6%84%8F%E6%80%9D%E5%85%AB%E9%93%BE%E6%8E%A5"><span class="toc-number">5.1.</span> <span class="toc-text">没意思（八）链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">处理流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%AF%B9%E8%B1%A1%E6%96%87%E4%BB%B6"><span class="toc-number">5.1.2.</span> <span class="toc-text">三种对象文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">5.1.3.</span> <span class="toc-text">静态链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6"><span class="toc-number">5.1.4.</span> <span class="toc-text">可重定位目标文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E8%A1%A8%E4%B8%8E%E7%AC%A6%E5%8F%B7"><span class="toc-number">5.1.5.</span> <span class="toc-text">符号表与符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">5.1.6.</span> <span class="toc-text">链接过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90"><span class="toc-number">5.1.6.1.</span> <span class="toc-text">符号解析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E8%A7%A3%E6%9E%90"><span class="toc-number">5.1.6.1.1.</span> <span class="toc-text">局部符号引用解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E8%A7%A3%E6%9E%90"><span class="toc-number">5.1.6.1.2.</span> <span class="toc-text">全局符号引用解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">5.1.6.1.3.</span> <span class="toc-text">重定位</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="toc-number">5.1.7.</span> <span class="toc-text">静态库与共享库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-number">5.1.7.1.</span> <span class="toc-text">静态库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="toc-number">5.1.7.2.</span> <span class="toc-text">共享库</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/10/%E6%9C%89%E7%82%B9%E6%84%8F%E6%80%9D%EF%BC%8C%E6%B2%A1%E7%82%B9%E6%84%8F%E6%80%9D%EF%BC%88%E4%B8%80%EF%BC%89/" title="有点意思，没点意思（一）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/68987a3758cb8da5c816a63a.png?_r_=f5a4d755-028e-80e4-4bfb-947faaf7a14a" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="有点意思，没点意思（一）"/></a><div class="content"><a class="title" href="/2025/08/10/%E6%9C%89%E7%82%B9%E6%84%8F%E6%80%9D%EF%BC%8C%E6%B2%A1%E7%82%B9%E6%84%8F%E6%80%9D%EF%BC%88%E4%B8%80%EF%BC%89/" title="有点意思，没点意思（一）">有点意思，没点意思（一）</a><time datetime="2025-08-10T10:37:42.000Z" title="发表于 2025-08-10 18:37:42">2025-08-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/17/Spring/" title="Spring"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/68987a3758cb8da5c816a63b.png?_r_=cc9361bd-ad4f-30c6-7832-c810d5621a4d" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring"/></a><div class="content"><a class="title" href="/2025/03/17/Spring/" title="Spring">Spring</a><time datetime="2025-03-17T15:34:25.000Z" title="发表于 2025-03-17 23:34:25">2025-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/24/Skyout%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/" title="Skyout环境配置指南"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/68987a3758cb8da5c816a63a.png?_r_=33b5a650-358b-35c8-fa44-dfce2101ff9e" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Skyout环境配置指南"/></a><div class="content"><a class="title" href="/2025/02/24/Skyout%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/" title="Skyout环境配置指南">Skyout环境配置指南</a><time datetime="2025-02-24T09:08:51.000Z" title="发表于 2025-02-24 17:08:51">2025-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/18/page/" title="网站(重要)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/68986fc858cb8da5c816a433.png?_r_=9aaf6517-8864-e33a-a24c-a06b24b826ac" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网站(重要)"/></a><div class="content"><a class="title" href="/2025/02/18/page/" title="网站(重要)">网站(重要)</a><time datetime="2025-02-18T09:48:10.000Z" title="发表于 2025-02-18 17:48:10">2025-02-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/08/C++(%E4%B8%89%EF%BC%89/" title="C++ part third"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.imgdb.cn/item/68987a3758cb8da5c816a63a.png?_r_=c4e6d4ff-8bf3-7155-22f9-a5735455ebff" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ part third"/></a><div class="content"><a class="title" href="/2025/02/08/C++(%E4%B8%89%EF%BC%89/" title="C++ part third">C++ part third</a><time datetime="2025-02-08T14:38:00.000Z" title="发表于 2025-02-08 22:38:00">2025-02-08</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By 织</div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">3</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CS/" style="font-size: 0.88rem;">CS<sup>6</sup></a><a href="/tags/CSAPP/" style="font-size: 0.88rem;">CSAPP<sup>1</sup></a><a href="/tags/JAVA/" style="font-size: 0.88rem;">JAVA<sup>1</sup></a><a href="/tags/Summary/" style="font-size: 0.88rem;">Summary<sup>1</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 0.88rem;">后端<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2024 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 织 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>